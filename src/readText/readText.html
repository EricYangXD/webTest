<!--
 * @Author: Eric YangXinde
 * @Date: 2019-01-03 16:38:03
 * @LastModifiedBy: Eric YangXinde
 * @LastEditTime: 2019-01-03 16:38:03
 * @Description: 
 -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1" />
        <script src="../../js/zepto.min.js"></script>
        <script src="../../js/jquery.js"></script>
        <title>read text</title>
    </head>

    <body>
        <div>
            <p>
                请把光标移动到文字上。绝对是发了、开始发了空间发挥。了看法交电话费拉活！雷锋大家好弗利“萨花费了福”建哈市将罚款？和福建师范接口，时傅雷家书临时工韩国，就开始刚开始更健康。
            </p>
        </div>
        <script>
            // 标签朗读
            // 这个很简单了，只用根据当前是什么标签，给出提示即可。
            // 标签朗读文本
            var tagTextConfig = {
                a: "链接",
                "input[text]": "文本输入框",
                "input[password]": "密码输入框",
                button: "按钮",
                img: "图片"
            };
            // 还有需要朗读的标签，继续再添加即可。
            // 然后根据标签，返回前缀文本即可。
            /**
             * 获取标签朗读文本
             * @param {HTMLElement} el 要处理的HTMLElement
             * @returns {String}   朗读文本
             */
            function getTagText(el) {
                if (!el) return "";
                var tagName = el.tagName.toLowerCase();
                // 处理input等多属性元素
                switch (tagName) {
                    case "input":
                        tagName += "[" + el.type + "]";
                        break;
                    default:
                        break;
                }
                // 标签的功能提醒和作用应该有间隔，因此在最后加入一个空格
                return (tagTextConfig[tagName] || "") + " ";
            }
            // 获取完整的朗读文本就更简单了，先取标签的功能提醒，再取标签的文本即可。
            // 文本内容优先取 title 其次 alt 最后 innerText。
            /**
             * 获取完整朗读文本
             * @param {HTMLElement} el 要处理的HTMLElement
             * @returns {String}   朗读文本
             */
            function getText(el) {
                if (!el) return "";
                return (
                    getTagText(el) + (el.title || el.alt || el.innerText || "")
                );
            }
            // 这样就可以获取到一个标签的功能提醒和内容的全部带朗读文本了。

            // 正文分隔
            // 首先准备了正文分隔的配置：
            // 正文拆分配置
            var splitConfig = {
                // 内容分段标签名称
                unitTag: "p",
                // 正文中分隔正则表达式
                splitReg: /[,;，；。]/g,
                // 包裹标签名
                wrapTag: "label",
                // 包裹标签类名
                wrapCls: "speak-lable",
                // 高亮样式名和样式
                hightlightCls: "speak-help-hightlight",
                hightStyle: "background: #000!important; color: #fff!important"
            };
            // 有文本节点这么个东西，删繁就简嘛，正则先到边上去，直接处理段落的所有节点不就行了。
            // 文本节点则分隔直接包裹，标签节点则对内容进行包裹，这种情况下处理的直接是dom，更省事。
            // 文本节点里放标签？这是在开玩笑么，是也不是。文本节点里确实只能放文本，但是我把标签直接放进去，它会自动转义，那最后再替换出来不就行了。
            /**
             * 正文内容分段处理
             * @param {jQueryObject/HTMLElement/String}  $content 要处理的正文jQ对象或HTMLElement或其对应选择器
             */
            function splitConent($content) {
                $content = $($content);

                $content.find(splitConfig.unitTag).each(function(index, item) {
                    var $item = $(item),
                        text = $.trim($item.text());
                    if (!text) return;

                    var nodes = $item[0].childNodes;

                    $.each(nodes, function(i, node) {
                        switch (node.nodeType) {
                            case 3:
                                // text 节点
                                // 由于是文本节点，标签被转义了，后续再转回来
                                node.data =
                                    "<" +
                                    splitConfig.wrapTag +
                                    ">" +
                                    node.data.replace(
                                        splitConfig.splitReg,
                                        "</" +
                                            splitConfig.wrapTag +
                                            ">$&<" +
                                            splitConfig.wrapTag +
                                            ">"
                                    ) +
                                    "</" +
                                    splitConfig.wrapTag +
                                    ">";
                                break;
                            case 1:
                                // 元素节点
                                var innerHtml = node.innerHTML,
                                    start = "",
                                    end = "";
                                // 如果内部还有直接标签，先去掉
                                var startResult = /^<\w+?>/.exec(innerHtml);
                                if (startResult) {
                                    start = startResult[0];
                                    innerHtml = innerHtml.substr(start.length);
                                }
                                var endResult = /<\/\w+?>$/.exec(innerHtml);
                                if (endResult) {
                                    end = endResult[0];
                                    innerHtml = innerHtml.substring(
                                        0,
                                        endResult.index
                                    );
                                }
                                // 更新内部内容
                                node.innerHTML =
                                    start +
                                    "<" +
                                    splitConfig.wrapTag +
                                    ">" +
                                    innerHtml.replace(
                                        splitConfig.splitReg,
                                        "</" +
                                            splitConfig.wrapTag +
                                            ">$&<" +
                                            splitConfig.wrapTag +
                                            ">"
                                    ) +
                                    "</" +
                                    splitConfig.wrapTag +
                                    ">" +
                                    end;
                                break;
                            default:
                                break;
                        }
                    });

                    // 处理文本节点中被转义的html标签
                    $item[0].innerHTML = $item[0].innerHTML
                        .replace(
                            new RegExp("<" + splitConfig.wrapTag + ">", "g"),
                            "<" + splitConfig.wrapTag + ">"
                        )
                        .replace(
                            new RegExp("</" + splitConfig.wrapTag + ">", "g"),
                            "</" + splitConfig.wrapTag + ">"
                        );
                    $item
                        .find(splitConfig.wrapTag)
                        .addClass(splitConfig.wrapCls);
                });
                // ES5之前JavaScript并不支持正则的后行断言（也就是正则表达式中“后顾”）。所以没办法对包裹标签前后的 < 和 > 进行精准替换，只能连同标签名一起替换。
            }

            // 事件处理
            // 在上面完成了文本获取和段落分隔，下面要做的就是鼠标移动上去时获取文本触发朗读即可，移开时停止朗读即可。
            // 鼠标移动，只读一次，基于这两点原因，使用 mouseenter 和 mouseleave 事件来完成。
            // 原因：
            // 不冒泡，不会触发父元素的再次朗读
            // 不重复触发，一个元素内移动时不会重复触发。

            /**
             * 在页面上写入高亮样式
             */
            function createStyle() {
                if (document.getElementById("speak-light-style")) return;
                var style = document.createElement("style");
                style.id = "speak-light-style";
                style.innerText =
                    "." +
                    splitConfig.hightlightCls +
                    "{" +
                    splitConfig.hightStyle +
                    "}";
                document.getElementsByTagName("head")[0].appendChild(style);
            }
            // 非正文需要朗读的标签 逗号分隔
            var speakTags =
                "a, p, span, h1, h2, h3, h4, h5, h6, img, input, button";
            $(document)
                .on("mouseenter.speak-help", speakTags, function(e) {
                    var $target = $(e.target);
                    // 排除段落内的
                    if (
                        $target.parents("." + splitConfig.wrapCls).length ||
                        $target.find("." + splitConfig.wrapCls).length
                    ) {
                        return;
                    }
                    // 图片样式单独处理 其他样式统一处理
                    if (e.target.nodeName.toLowerCase() === "img") {
                        $target.css({
                            border: "2px solid #000"
                        });
                    } else {
                        $target.addClass(splitConfig.hightlightCls);
                    }
                    // 开始朗读
                    speakText(getText(e.target));
                })
                .on("mouseleave.speak-help", speakTags, function(e) {
                    var $target = $(e.target);
                    if ($target.find("." + splitConfig.wrapCls).length) {
                        return;
                    }
                    // 图片样式
                    if (e.target.nodeName.toLowerCase() === "img") {
                        $target.css({
                            border: "none"
                        });
                    } else {
                        $target.removeClass(splitConfig.hightlightCls);
                    }
                    // 停止语音
                    stopSpeak();
                });
            // 段落内文本朗读
            $(document)
                .on(
                    "mouseenter.speak-help",
                    "." + splitConfig.wrapCls,
                    function(e) {
                        $(this).addClass(splitConfig.hightlightCls);
                        // 开始朗读
                        speakText(getText(this));
                    }
                )
                .on(
                    "mouseleave.speak-help",
                    "." + splitConfig.wrapCls,
                    function(e) {
                        $(this).removeClass(splitConfig.hightlightCls);
                        // 停止语音
                        stopSpeak();
                    }
                );
            // 注意要把针对段落的语音处理和其他地方的分开。为什么？ 因为段落是个块级元素，鼠标移入段落中的空白时，如：段落前后空白、首行缩进、末行剩余空白等，是不应该触发朗读的，如果不阻止掉，进行这些区域将直接触发整段文字的朗读，失去了我们对段落文本内分隔的意义，而且，无论什么方式转化语音都是要时间的，大段内容可能需要较长时间，影响语音输出的体验。

            // 文本合成语音
            // 上面我们是直接使用了 speakText(text) 和 stopSpeak() 两个方法来触发语音的朗读和停止。
            // 我们来看下如何实现这个两个功能。
            // 其实现代浏览器默认已经提供了上面功能：
            // var speechSU = new window.SpeechSynthesisUtterance();
            // speechSU.text = '你好，世界！';
            // window.speechSynthesis.speak(speechSU);
            // 上面的两个方法可以写为：
            var speaker = new window.SpeechSynthesisUtterance();
            var speakTimer, stopTimer;

            // 开始朗读
            function speakText(text) {
                clearTimeout(speakTimer);
                window.speechSynthesis.cancel();
                speakTimer = setTimeout(function() {
                    speaker.text = text;
                    window.speechSynthesis.speak(speaker);
                }, 200);
            }

            // 停止朗读
            function stopSpeak() {
                clearTimeout(stopTimer);
                clearTimeout(speakTimer);
                stopTimer = setTimeout(function() {
                    window.speechSynthesis.cancel();
                }, 20);
            }
            // 因为语音合成本来是个异步的操作，因此在过程中进行以上处理。
        </script>
    </body>
</html>
