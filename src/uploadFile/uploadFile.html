<!DOCTYPE html>
<html lang="en">

<head>
    <title>文件上传</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script lang="javascript" src="../js/jquery.js"></script>
    <style>
        #holder {
            border: 10px dashed #ccc;
            width: 200px;
            min-height: 200px;
            margin: 20px auto;
            padding: 40px;
        }
        
        #holder div {
            border: 10px dashed #ccc;
            width: 50px;
            min-height: 50px;
            margin: 20px auto;
            padding: 10px;
        }
        
        #holder.hover {
            border: 10px dashed #0c0;
        }
    </style>

</head>

<body>

    <div id="holder">adhjhdjkhakh<br> adhjhdjkhakh
        <br>adhjhdjkhakh<br>
        <div>3423412414</div>
    </div>
    <!-- 文件上传的传统形式，是使用表单元素file：所有浏览器都支持下面的代码。 -->
    <form id="upload-form" action="upload.php" method="post" enctype="multipart/form-data">
        <input type="file" id="upload" name="upload" /> <br />
        <input type="submit" value="Upload" />
    </form>
    <!-- 进度条 -->
    <progress id="uploadprogress" min="0" max="100" value="0">0</progress>

    <script>
        // 传统的表单上传，属于"同步上传"。也就是说，点击上传按钮后，网页"锁死"，用户只能等待上传结束，然后浏览器刷新，跳到表单的action属性指定的网址。在HTML5没有出现之前，只能使用iframe做到这一点。用户点击submit时，动态插入一个iframe元素（以下代码使用了jQuery函数库）。
        var form = $("#upload-form");　　
        form.on('submit', function() {　　　　
            // 此处动态插入iframe元素
        });
        // 插入iframe的代码如下：
        var seed = Math.floor(Math.random() * 1000);　　
        var id = "uploader-frame-" + seed;　　
        var callback = "uploader-cb-" + seed;　　
        var iframe = $('<iframe id="' + id + '" name="' + id + '" style="display:none;">');　　
        var url = form.attr('action');　　
        form.attr('target', id).append(iframe).attr('action', url + '?iframe=' + callback);
        // 最后一行，有两个地方值得注意。首先，它为表单添加target属性，指向动态插入的iframe窗口，这使得上传结束后，服务器将结果返回iframe窗口，所以当前页面就不会跳转了。其次，它在action属性指定的上传网址的后面，添加了一个参数，使得服务器知道回调函数的名称。这样就能将服务器返回的信息，从iframe窗口传到上层页面。
        // 服务器（upload.php）返回的信息，应该是如下形式：
        // 　　<script type="text/javascript">　　　
        window.top.window['callback'](data);
        // 　　<\/script>
        // 然后，在当前网页定义回调函数：
        window[callback] = function(data) {　　　　
            console.log('received callback:', data);　　　　
            iframe.remove(); //removing iframe　
            form.removeAttr('target');　　　　
            form.attr('action', url);　　　　
            window[callback] = undefined; //removing callback
        };

        // HTML5提出了XMLHttpRequest对象的第二版，从此ajax能够上传文件了。这是真正的"异步上传"，是将来的主流。
        // ajax上传代码，放在表单的submit事件回调函数中：
        form.on('submit', function() {　　　　
            // 此处进行ajax上传
        });
        // 我们主要用的是FormData对象，它能够构建类似表单的键值对。
        // 检查是否支持FormData　
        if (window.FormData) {　　　　　
            var formData = new FormData();　　　　
            // 建立一个upload表单项，值为上传的文件
            formData.append('upload', document.getElementById('upload').files[0]);　　　　
            var xhr = new XMLHttpRequest();　　　　
            xhr.open('POST', $(this).attr('action'));　　　　　　　
            // XMLHttpRequest第二版还定义了一个progress事件，可以用来制作进度条。
            // 首先，在页面中放置一个HTML元素progress。
            // 然后，定义progress事件的回调函数。
            xhr.upload.onprogress = function(event) {　　　　 //上传进度条，上传和下载是两个函数
                if (event.lengthComputable) {　　　　　　
                    var complete = (event.loaded / event.total * 100 | 0);　　　　　　
                    var progress = document.getElementById('uploadprogress');　　　　　　
                    progress.value = progress.innerHTML = complete;　　　　
                }　　
            };
            // 定义上传完成后的回调函数
            xhr.onload = function() {　　　　　　
                if (xhr.status === 200) {　　　　　　　　
                    console.log('上传成功');　　　　　　
                } else {　　　　　　　　
                    console.log('出错了');　　　　　　
                }　　　　
            };　　　　
            xhr.send(formData);　　
        }

        // 如果上传的是图片文件，利用File API，我们可以做一个图片文件的预览。这里主要用到FileReader对象。
        // 检查是否支持FileReader对象
        if (typeof FileReader != 'undefined') {　　　　
            var acceptedTypes = {　　　　　　
                'image/png': true,
                　　　　'image/jpeg': true,
                　　　　'image/gif': true　　　　
            };　　　　
            if (acceptedTypes[document.getElementById('upload').files[0].type] === true) {　　　　　　
                var reader = new FileReader();　　　　　　
                reader.onload = function(event) {　　　　　　　　
                    var image = new Image();　　　　　　　　
                    image.src = event.target.result;　　　　　　　　
                    image.width = 100;　　　　　　　　
                    document.body.appendChild(image);　　　　　　
                };　　　　
                reader.readAsDataURL(document.getElementById('upload').files[0]);　　　　
            }　　
        }


        // 检查浏览器是否支持拖放上传。
        // 拖放文件的代码，主要是定义dragover、dragend和drop这三个事件。
        if ('draggable' in document.createElement('span')) {　　　　
            var holder = document.getElementById('holder');　　　　
            holder.ondragover = function() {
                this.className = 'hover';
                return false;
            };　　　　
            holder.ondragend = function() {
                this.className = '';
                return false;
            };　　　　
            holder.ondrop = function(event) {　　　　　　
                event.preventDefault();　　　　　　
                this.className = '';　　　　　　
                var files = event.dataTransfer.files;　　　　　　
                // do something with files
            };　　
        }
    </script>

</body>

</html>